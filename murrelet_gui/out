#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::collections::HashMap;
use murrelet_gui::{
    CanMakeGUI, MurreletEnumValGUI, MurreletGUI, MurreletGUISchema, ValueGUI,
};
pub struct BasicTypes {
    a_number: f32,
    b_number: usize,
    c_number: u64,
    d_number: i32,
    bool: bool,
    something: Vec<f32>,
    s: String,
    #[murrelet_gui(reference = "test")]
    referenced_string: String,
}
impl murrelet_gui::CanMakeGUI for BasicTypes {
    fn make_gui() -> murrelet_gui::MurreletGUISchema {
        let mut v = ::alloc::vec::Vec::new();
        v.push(("a_number".to_owned(), f32::make_gui()));
        v.push(("b_number".to_owned(), usize::make_gui()));
        v.push(("c_number".to_owned(), u64::make_gui()));
        v.push(("d_number".to_owned(), i32::make_gui()));
        v.push(("bool".to_owned(), bool::make_gui()));
        v.push(("something".to_owned(), Vec::<f32>::make_gui()));
        v.push(("s".to_owned(), String::make_gui()));
        v.push((
            "referenced_string".to_owned(),
            murrelet_gui::MurreletGUISchema::Val(
                murrelet_gui::ValueGUI::Name("test".to_owned(), false),
            ),
        ));
        murrelet_gui::MurreletGUISchema::Struct("BasicTypes".to_owned(), v)
    }
}
fn custom_func() -> MurreletGUISchema {
    MurreletGUISchema::Val(ValueGUI::Num)
}
pub struct OverridesAndRecursive {
    a_number: f32,
    something: Vec<BasicTypes>,
    #[murrelet_gui(func = "custom_func")]
    label: String,
    #[murrelet_gui(kind = "skip")]
    b: HashMap<String, String>,
}
impl murrelet_gui::CanMakeGUI for OverridesAndRecursive {
    fn make_gui() -> murrelet_gui::MurreletGUISchema {
        let mut v = ::alloc::vec::Vec::new();
        v.push(("a_number".to_owned(), f32::make_gui()));
        v.push(("something".to_owned(), Vec::<BasicTypes>::make_gui()));
        v.push(("label".to_owned(), custom_func()));
        v.push(("b".to_owned(), murrelet_gui::MurreletGUISchema::Skip));
        murrelet_gui::MurreletGUISchema::Struct("OverridesAndRecursive".to_owned(), v)
    }
}
enum EnumTest {
    A,
    B(OverridesAndRecursive),
}
impl murrelet_gui::CanMakeGUI for EnumTest {
    fn make_gui() -> murrelet_gui::MurreletGUISchema {
        murrelet_gui::MurreletGUISchema::Enum(
            "EnumTest".to_owned(),
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    murrelet_gui::MurreletEnumValGUI::Unit("A".to_owned()),
                    (murrelet_gui::MurreletEnumValGUI::Unnamed(
                        "B".to_string(),
                        OverridesAndRecursive::make_gui(),
                    )),
                ]),
            ),
        )
    }
}
struct SimpleNewtype(f32);
impl murrelet_gui::CanMakeGUI for SimpleNewtype {
    fn make_gui() -> murrelet_gui::MurreletGUISchema {
        murrelet_gui::MurreletGUISchema::new_type(
            "SimpleNewtype".to_owned(),
            f32::make_gui(),
        )
    }
}
fn main() {
    let test_val = BasicTypes::make_gui();
    let basic_types_schema = MurreletGUISchema::Struct(
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                ("a_number".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("b_number".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("c_number".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("d_number".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("bool".to_owned(), MurreletGUISchema::Val(ValueGUI::Bool)),
                (
                    "something".to_owned(),
                    MurreletGUISchema::list(MurreletGUISchema::Val(ValueGUI::Num)),
                ),
                ("s".to_owned(), MurreletGUISchema::Skip),
                (
                    "referenced_string".to_owned(),
                    MurreletGUISchema::Val(ValueGUI::Name("test".to_owned())),
                ),
            ]),
        ),
    );
    match (&test_val, &basic_types_schema) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let test_val = OverridesAndRecursive::make_gui();
    let overrides_and_recursive_schema = MurreletGUISchema::Struct(
        <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                ("a_number".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("something".to_owned(), MurreletGUISchema::list(basic_types_schema)),
                ("label".to_owned(), MurreletGUISchema::Val(ValueGUI::Num)),
                ("b".to_owned(), MurreletGUISchema::Skip),
            ]),
        ),
    );
    match (&test_val, &overrides_and_recursive_schema) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
    let test_val = EnumTest::make_gui();
    match (
        &test_val,
        &MurreletGUISchema::Enum(
            <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([
                    (MurreletEnumValGUI::Unit("A".to_owned())),
                    (MurreletEnumValGUI::Unnamed(
                        "B".to_owned(),
                        overrides_and_recursive_schema,
                    )),
                ]),
            ),
        ),
    ) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };
}
